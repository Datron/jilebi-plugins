{"version":3,"file":"index.js","sources":["index.ts"],"sourcesContent":["// Jilebi Fetch Plugin - Deno Implementation with MCP Compatible Returns\n// Converts the MCP fetch server to jilebi plugin format\n// All functions take (request, env) parameters as required by jilebi\n\n// MCP Protocol interfaces\ninterface MCPTextContent {\n  type: \"text\";\n  text: string;\n}\n\ninterface MCPResult {\n  content: MCPTextContent[];\n  isError?: boolean;\n}\n\ninterface FetchRequest {\n  url: string;\n  max_length?: number;\n  start_index?: number;\n  raw?: boolean;\n}\n\nconst DEFAULT_USER_AGENT = \"jilebi-server\";\n\n/**\n * Validate URL format\n */\nfunction is_valid_url(urlString: string): boolean {\n  try {\n    const url = new URL(urlString);\n    return url.protocol === \"http:\" || url.protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extract only the body content from HTML\n * Returns the innerHTML of the body tag, or the original HTML if no body found\n */\nfunction extractBodyContent(html: string): string {\n  const bodyMatch = html.match(/<body\\b[^>]*>([\\s\\S]*?)<\\/body>/i);\n  return bodyMatch ? bodyMatch[1] : html;\n}\n\n/**\n * Fetch a URL and return its content\n * Tool function for the fetch tool\n */\nexport async function fetch_url(\n  request: FetchRequest,\n  _env: Environment,\n): Promise<MCPResult> {\n  try {\n    const { url, max_length = 5000, start_index = 0, raw = false } = request;\n\n    // Validate URL\n    if (!url) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"URL is required\",\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    if (!is_valid_url(url)) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Invalid URL: ${url}. URL must be a valid HTTP or HTTPS URL.`,\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    // Validate parameters\n    if (max_length <= 0 || max_length > 1000000) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"max_length must be between 1 and 1000000\",\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    if (start_index < 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"start_index must be non-negative\",\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    // Fetch the URL\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          \"User-Agent\": DEFAULT_USER_AGENT,\n        },\n        redirect: \"follow\",\n      });\n    } catch (error) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to fetch ${url}: ${error instanceof Error ? error.message : String(error)}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    if (!response.ok) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to fetch ${url} - status code ${response.status}`,\n          },\n        ],\n        isError: true,\n      };\n    }\n\n    const pageRaw = await response.text();\n    const contentType = response.headers.get(\"content-type\") || \"\";\n\n    // Determine if content is HTML\n    const isPageHtml =\n      pageRaw.slice(0, 100).toLowerCase().includes(\"<html\") ||\n      contentType.includes(\"text/html\") ||\n      !contentType;\n\n    let content: string;\n    let prefix = \"\";\n\n    if (isPageHtml && !raw) {\n      content = html2markdown(pageRaw);\n      if (!content) {\n        content = \"<error>Page failed to be simplified from HTML</error>\";\n      }\n    } else {\n      content = pageRaw;\n      if (!isPageHtml) {\n        prefix = `Content type ${contentType} cannot be simplified to markdown, but here is the raw content:\\n`;\n      }\n    }\n\n    // Handle pagination\n    const originalLength = content.length;\n\n    if (start_index >= originalLength) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"<error>No more content available.</error>\",\n          },\n        ],\n      };\n    }\n\n    let truncatedContent = content.slice(start_index, start_index + max_length);\n    if (!truncatedContent) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"<error>No more content available.</error>\",\n          },\n        ],\n      };\n    }\n\n    const actualContentLength = truncatedContent.length;\n    const remainingContent =\n      originalLength - (start_index + actualContentLength);\n\n    // Add truncation notice if there's more content\n    if (actualContentLength === max_length && remainingContent > 0) {\n      const nextStart = start_index + actualContentLength;\n      truncatedContent += `\\n\\n<error>Content truncated. Call the fetch tool with a start_index of ${nextStart} to get more content.</error>`;\n    }\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `${prefix}Contents of ${url}:\\n${truncatedContent}`,\n        },\n      ],\n    };\n  } catch (error) {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Failed to fetch URL: ${error instanceof Error ? error.message : String(error)}`,\n        },\n      ],\n      isError: true,\n    };\n  }\n}\n"],"names":[],"mappings":"AAAA;AACA;AACA;AAoBA,MAAM,kBAAkB,GAAG,eAAe;AAE1C;;AAEG;AACH,SAAS,YAAY,CAAC,SAAiB,EAAA;AACrC,IAAA,IAAI;AACF,QAAA,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;QAC9B,OAAO,GAAG,CAAC,QAAQ,KAAK,OAAO,IAAI,GAAG,CAAC,QAAQ,KAAK,QAAQ;IAC9D;AAAE,IAAA,MAAM;AACN,QAAA,OAAO,KAAK;IACd;AACF;AAWA;;;AAGG;AACI,eAAe,SAAS,CAC7B,OAAqB,EACrB,IAAiB,EAAA;AAEjB,IAAA,IAAI;AACF,QAAA,MAAM,EAAE,GAAG,EAAE,UAAU,GAAG,IAAI,EAAE,WAAW,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,EAAE,GAAG,OAAO;;QAGxE,IAAI,CAAC,GAAG,EAAE;YACR,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,iBAAiB;AACxB,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;AAEA,QAAA,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;YACtB,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;wBACZ,IAAI,EAAE,CAAA,aAAA,EAAgB,GAAG,CAAA,wCAAA,CAA0C;AACpE,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;;QAGA,IAAI,UAAU,IAAI,CAAC,IAAI,UAAU,GAAG,OAAO,EAAE;YAC3C,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,0CAA0C;AACjD,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;AAEA,QAAA,IAAI,WAAW,GAAG,CAAC,EAAE;YACnB,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,kCAAkC;AACzC,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;;AAGA,QAAA,IAAI,QAAkB;AACtB,QAAA,IAAI;AACF,YAAA,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE;AAC1B,gBAAA,OAAO,EAAE;AACP,oBAAA,YAAY,EAAE,kBAAkB;AACjC,iBAAA;AACD,gBAAA,QAAQ,EAAE,QAAQ;AACnB,aAAA,CAAC;QACJ;QAAE,OAAO,KAAK,EAAE;YACd,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;wBACZ,IAAI,EAAE,mBAAmB,GAAG,CAAA,EAAA,EAAK,KAAK,YAAY,KAAK,GAAG,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA,CAAE;AAC1F,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;AAEA,QAAA,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE;YAChB,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,CAAA,gBAAA,EAAmB,GAAG,kBAAkB,QAAQ,CAAC,MAAM,CAAA,CAAE;AAChE,qBAAA;AACF,iBAAA;AACD,gBAAA,OAAO,EAAE,IAAI;aACd;QACH;AAEA,QAAA,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE;AACrC,QAAA,MAAM,WAAW,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE;;AAG9D,QAAA,MAAM,UAAU,GACd,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC;AACrD,YAAA,WAAW,CAAC,QAAQ,CAAC,WAAW,CAAC;AACjC,YAAA,CAAC,WAAW;AAEd,QAAA,IAAI,OAAe;QACnB,IAAI,MAAM,GAAG,EAAE;AAEf,QAAA,IAAI,UAAU,IAAI,CAAC,GAAG,EAAE;AACtB,YAAA,OAAO,GAAG,aAAa,CAAC,OAAO,CAAC;YAChC,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,GAAG,uDAAuD;YACnE;QACF;aAAO;YACL,OAAO,GAAG,OAAO;YACjB,IAAI,CAAC,UAAU,EAAE;AACf,gBAAA,MAAM,GAAG,CAAA,aAAA,EAAgB,WAAW,CAAA,iEAAA,CAAmE;YACzG;QACF;;AAGA,QAAA,MAAM,cAAc,GAAG,OAAO,CAAC,MAAM;AAErC,QAAA,IAAI,WAAW,IAAI,cAAc,EAAE;YACjC,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,2CAA2C;AAClD,qBAAA;AACF,iBAAA;aACF;QACH;AAEA,QAAA,IAAI,gBAAgB,GAAG,OAAO,CAAC,KAAK,CAAC,WAAW,EAAE,WAAW,GAAG,UAAU,CAAC;QAC3E,IAAI,CAAC,gBAAgB,EAAE;YACrB,OAAO;AACL,gBAAA,OAAO,EAAE;AACP,oBAAA;AACE,wBAAA,IAAI,EAAE,MAAM;AACZ,wBAAA,IAAI,EAAE,2CAA2C;AAClD,qBAAA;AACF,iBAAA;aACF;QACH;AAEA,QAAA,MAAM,mBAAmB,GAAG,gBAAgB,CAAC,MAAM;QACnD,MAAM,gBAAgB,GACpB,cAAc,IAAI,WAAW,GAAG,mBAAmB,CAAC;;QAGtD,IAAI,mBAAmB,KAAK,UAAU,IAAI,gBAAgB,GAAG,CAAC,EAAE;AAC9D,YAAA,MAAM,SAAS,GAAG,WAAW,GAAG,mBAAmB;AACnD,YAAA,gBAAgB,IAAI,CAAA,wEAAA,EAA2E,SAAS,CAAA,6BAAA,CAA+B;QACzI;QAEA,OAAO;AACL,YAAA,OAAO,EAAE;AACP,gBAAA;AACE,oBAAA,IAAI,EAAE,MAAM;AACZ,oBAAA,IAAI,EAAE,CAAA,EAAG,MAAM,eAAe,GAAG,CAAA,GAAA,EAAM,gBAAgB,CAAA,CAAE;AAC1D,iBAAA;AACF,aAAA;SACF;IACH;IAAE,OAAO,KAAK,EAAE;QACd,OAAO;AACL,YAAA,OAAO,EAAE;AACP,gBAAA;AACE,oBAAA,IAAI,EAAE,MAAM;AACZ,oBAAA,IAAI,EAAE,CAAA,qBAAA,EAAwB,KAAK,YAAY,KAAK,GAAG,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA,CAAE;AACvF,iBAAA;AACF,aAAA;AACD,YAAA,OAAO,EAAE,IAAI;SACd;IACH;AACF;;;;"}